
## Fiber

```js
export type Fiber = {|
  // 根据ReactElement组件的 type 进行生成
  tag: WorkTag,
  // 和ReactElement组件的 key 一致
  key: null | string,
  // 一般来讲和ReactElement组件的 type 一致
  // 某些情况不同，比如FunctionComponent使用React.memo包裹
	elementType: any,
  // 一般来讲和fiber.elementType一致. 一些特殊情形下,
  // 比如在开发环境下为了兼容热更新(HotReloading), 会对function, class, ForwardRef类型的ReactElement做一定的处理,
  // 这种情况会区别于fiber.elementType
  // 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
  type: any,
  // 与fiber关联的局部状态节点(比如: HostComponent类型指向与fiber节点对应的 dom 节点;
  // 根节点fiber.stateNode指向的是FiberRoot; class 类型节点其stateNode指向的是 class 实例)
  stateNode: any,

  // 指向父级Fiber节点
  return: Fiber | null,
  // 指向子Fiber节点
  child: Fiber | null,
  // 指向右边第一个兄弟Fiber节点
  sibling: Fiber | null,
  //  fiber 在兄弟节点中的索引, 如果是单节点默认为 0.
  index: number,

  // 指向在ReactElement组件上设置的 ref(string类型的ref除外,
  // 这种类型的ref已经不推荐使用, reconciler阶段会将string类型的ref转换成一个function类型)
  ref:| null
    | (((handle: mixed) => void) & {_stringRef: ?string, ...})
    | RefObject,

  // 从`ReactElement`对象传入的 props. 用于和`fiber.memoizedProps`比较可以得出属性是否变动
  pendingProps: any, // This type will be more specific once we overload the tag.
  // 上一次生成子节点时用到的属性, 生成子节点之后保持在内存中
  memoizedProps: any, // The props used to create the output.
  // 存储state更新的队列, 当前节点的state改动之后, 都会创建一个update对象添加到这个队列中.
  updateQueue: mixed,
  // 用于输出的state, 最终渲染所使用的state
  // 上一次生成子节点之后保持在内存中的局部状态.
  memoizedState: any,
  // 该fiber节点所依赖的(contexts, events)等
  dependencies: Dependencies | null,

  
  // 二进制位 Bitfield,继承至父节点,影响本 fiber 节点及其子树中所有节点.
  // 与 react 应用的运行模式有关(有 ConcurrentMode, BlockingMode, NoMode 等选项)
  mode: TypeOfMode,

  // Effect
  flags: Flags,
  //替代16.x版本中的 firstEffect, nextEffect. 当设置了 enableNewReconciler=true才会启用
  subtreeFlags: Flags,
  // 存储将要被删除的子节点. 当设置了 enableNewReconciler=true才会启用
  deletions: Array<Fiber> | null,

  // 单向链表, 指向下一个有副作用的fiber节点
  nextEffect: Fiber | null,
  // 指向副作用链表中的第一个fiber节点
  firstEffect: Fiber | null,
  // 指向副作用链表中的最后一个fiber节点
  lastEffect: Fiber | null,

  // 本fiber节点的优先级
  lanes: Lanes,
  // 子节点的优先级
  childLanes: Lanes,

  // 指向内存中的另一个fiber, 每个被更新过fiber节点在内存中都是成对出现(current和workInProgress)
  alternate: Fiber | null,

  actualDuration?: number,
  actualStartTime?: number,
	selfBaseDuration?: number,
  treeBaseDuration?: number,
|};
```

![[fiber.svg]]

## Update


- ReactDOM.render —— HostRoot
- this.setState —— ClassComponent
- this.forceUpdate —— ClassComponent
- useState —— FunctionComponent
- useReducer —— FunctionComponent


可以看到，一共三种组件（`HostRoot` | `ClassComponent` | `FunctionComponent`）可以触发更新。

由于不同类型组件工作方式不同，所以存在两种不同结构的`Update`，其中`ClassComponent`与`HostRoot`共用一套`Update`结构，`FunctionComponent`单独使用一种`Update`结构

```js
const update: Update<*> = {
  eventTime, // 任务时间
	lane, // 优先级
  suspenseConfig,
  tag: UpdateState, // 1,2,3,4 `UpdateState` | `ReplaceState` | `ForceUpdate` | `CaptureUpdate`
  payload: null, // 更新挂载的数据，不同类型组件挂载的数据不同。对于`ClassComponent`，`payload`为`this.setState`的第一个传参。对于`HostRoot`，`payload`为`ReactDOM.render`的第一个传参
  callback: null, // 更新的回调函数。
  next: null,
};
```

```js
export type UpdateQueue<State> = {|
  // 表示此队列的基础 state
  baseState: State,
  // 指向基础队列的队首
  firstBaseUpdate: Update<State> | null,
  // 指向基础队列的队尾
  lastBaseUpdate: Update<State> | null,
  // 共享队列
  shared: SharedQueue<State>,
  // 用于保存有callback回调函数的 update 对象, 在commit之后, 会依次调用这里的回调函数.
  effects: Array<Update<State>> | null,
|};
```

## Hook

```js
export type Hook = {|
  // 内存状态, 用于输出成最终的fiber树
  memoizedState: any,
  // 基础状态, 当Hook.queue更新过后, baseState也会更新.
  baseState: any,
  // 基础状态队列, 在reconciler阶段会辅助状态合并.
  baseQueue: Update<any, any> | null,
  // 指向一个Update队列
  queue: any,
  // 指向该function组件的下一个Hook对象, 使得多个Hook之间也构成了一个链表.
  next: Hook | null,
|};
```

## Effect

```js
export type Effect = {|
  tag: HookFlags,
  create: () => (() => void) | void, // `useEffect()`所传入的函数.
  destroy: (() => void) | void,
  deps: Array<mixed> | null,
  next: Effect,
|};


export const NoFlags = /*  */ 0b000;
export const HasEffect = /* */ 0b001; // 有副作用, 可以被触发
export const Layout = /*    */ 0b010; // dom突变后同步触发
export const Passive = /*   */ 0b100; // dom突变前异步触发
```